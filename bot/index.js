import express from "express";
import path from "path";
import cors from "cors";
import { Telegraf } from "telegraf";
import * as dotenv from "dotenv";
import csvParser from "csv-parser";
import fetch from "node-fetch";
import { v4 as uuidv4 } from "uuid";
import { createClient } from "@supabase/supabase-js";
import winston from "winston";
import retry from "async-retry";

// –ó–∞–≥—Ä—É–∑–∫–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è
dotenv.config();

// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ª–æ–≥–≥–µ—Ä–∞
const logger = winston.createLogger({
  level: "info",
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.Console(),
    new winston.transports.File({ filename: "logs/error.log", level: "error" }),
    new winston.transports.File({ filename: "logs/combined.log" }),
  ],
});

const app = express();
const PORT = process.env.PORT || 10000;
const __dirname = path.resolve();

const bot = new Telegraf(process.env.BOT_TOKEN);
const WEBAPP_URL =
  process.env.WEBAPP_URL || "https://lavandershopsite.onrender.com/webapp/index.html";

// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Supabase —Å —Ç–∞–π–º-–∞—É—Ç–æ–º
const supabase = createClient(process.env.SUPABASE_URL, process.env.SUPABASE_KEY, {
  fetch: (url, options) =>
    fetch(url, { ...options, timeout: 5000 }).catch((err) => {
      logger.error("Supabase fetch failed", { error: err.message });
      throw err;
    }),
});

// Middleware
app.use(cors());
app.use(express.json());
app.use("/webapp", express.static(path.join(__dirname, "webapp")));
app.use("/public", express.static(path.join(__dirname, "public")));

// –°–ª–æ–≤–∞—Ä—å —Å–∏–Ω–æ–Ω–∏–º–æ–≤ –¥–ª—è –ø–∞—Ä—Å–µ—Ä–∞ CSV
const columnSynonyms = {
  name: ["name", "title", "product_name", "item", "–Ω–∞–∑–≤–∞–Ω–∏–µ", "–∏–º—è", "–ø—Ä–æ–¥—É–∫—Ç", "—Ç–æ–≤–∞—Ä"],
  price: ["price", "cost", "value", "—Ü–µ–Ω–∞", "—Å—Ç–æ–∏–º–æ—Å—Ç—å"],
  description: ["description", "desc", "info", "details", "–æ–ø–∏—Å–∞–Ω–∏–µ", "–∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è", "–¥–µ—Ç–∞–ª–∏"],
  image_url: ["image", "img", "photo", "picture", "url", "image_url", "–∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ", "—Ñ–æ—Ç–æ", "—Å—Å—ã–ª–∫–∞"],
  category: ["category", "type", "group", "–∫–∞—Ç–µ–≥–æ—Ä–∏—è", "—Ç–∏–ø", "–≥—Ä—É–ø–ø–∞"],
  stock: ["stock", "quantity", "qty", "available", "–æ—Å—Ç–∞—Ç–æ–∫", "–∫–æ–ª–∏—á–µ—Å—Ç–≤–æ", "–≤_–Ω–∞–ª–∏—á–∏–∏"],
  tags: ["tags", "labels", "keywords", "—Ç–µ–≥–∏", "–º–µ—Ç–∫–∏", "–∫–ª—é—á–µ–≤—ã–µ_—Å–ª–æ–≤–∞"],
};

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏—è –∑–∞–≥–æ–ª–æ–≤–∫–æ–≤ CSV
const mapColumn = (header) => {
  const cleanHeader = header.toLowerCase().replace(/[_-\s]/g, "");
  for (const [field, synonyms] of Object.entries(columnSynonyms)) {
    if (synonyms.some((synonym) => cleanHeader.includes(synonym.toLowerCase()))) {
      return field;
    }
  }
  return null;
};

// –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç–∞–±–ª–∏—Ü—ã —Å –ø–æ–≤—Ç–æ—Ä–Ω—ã–º–∏ –ø–æ–ø—ã—Ç–∫–∞–º–∏
const checkTable = async (tableName) => {
  return await retry(
    async () => {
      const { data, error } = await supabase.from(tableName).select("*").limit(1);
      if (error) {
        logger.error(`Error checking table ${tableName}`, { error });
        throw new Error(error.message);
      }
      return !!data;
    },
    {
      retries: 3,
      factor: 2,
      minTimeout: 1000,
      maxTimeout: 5000,
      onRetry: (err, attempt) =>
        logger.warn(`Retrying checkTable ${tableName}, attempt ${attempt}`, { error: err.message }),
    }
  ).catch((err) => {
    logger.error(`Failed to check table ${tableName} after retries`, { error: err.message });
    return false;
  });
};

// –ü—Ä–æ–≤–µ—Ä–∫–∞ –∞–¥–º–∏–Ω-–ø—Ä–∞–≤
const isAdminUser = async (userId) => {
  const adminIdsFromEnv = process.env.ADMIN_IDS
    ? process.env.ADMIN_IDS.split(",").map((id) => id.trim())
    : [];
  if (adminIdsFromEnv.includes(userId)) {
    logger.info("Admin access granted via ADMIN_IDS", { userId });
    return true;
  }

  // –í—Ä–µ–º–µ–Ω–Ω–æ–µ –æ—Ç–∫–ª—é—á–µ–Ω–∏–µ Supabase –¥–æ —Ä–µ—à–µ–Ω–∏—è –ø—Ä–æ–±–ª–µ–º—ã
  logger.warn("Supabase check skipped due to connectivity issues");
  return false;
};

// –ö–æ–º–∞–Ω–¥–∞ /start
bot.start(async (ctx) => {
  const userId = ctx.from.id.toString();
  logger.info("Received /start command", { userId });

  let isAdmin = false;
  try {
    isAdmin = await isAdminUser(userId);
  } catch (err) {
    logger.error("Error checking admin status", { error: err.message, userId });
    ctx.reply("‚ùå –û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞, –Ω–æ –¥–æ—Å—Ç—É–ø –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω –ø–æ ID");
  }

  const buttons = [[{ text: "üõí –û—Ç–∫—Ä—ã—Ç—å –º–∞–≥–∞–∑–∏–Ω", web_app: { url: WEBAPP_URL } }]];
  if (isAdmin) {
    buttons.push([{ text: "üîë –ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å", callback_data: "admin_panel" }]);
  }

  await ctx.reply("‚ú® –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –º–∞–≥–∞–∑–∏–Ω –ø–æ—Å—Ç–µ–ª—å–Ω–æ–≥–æ –±–µ–ª—å—è! –í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:", {
    reply_markup: { inline_keyboard: buttons },
  });
  logger.info("Sent /start response", { userId, isAdmin });
});

// –ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å
bot.action("admin_panel", async (ctx) => {
  const userId = ctx.from.id.toString();
  logger.info("Received admin_panel action", { userId });

  let isAdmin = false;
  try {
    isAdmin = await isAdminUser(userId);
  } catch (err) {
    logger.error("Error checking admin status in admin_panel", { error: err.message, userId });
    return ctx.reply("‚ùå –û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞");
  }

  if (!isAdmin) {
    logger.warn("Admin access denied", { userId });
    return ctx.reply("üö´ –î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â—ë–Ω");
  }

  await ctx.reply("üîë –ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å:", {
    reply_markup: {
      inline_keyboard: [
        [
          { text: "üì¶ –ü–∞—Ä—Å–µ—Ä —Ç–æ–≤–∞—Ä–æ–≤", callback_data: "parse_products" },
          { text: "‚úèÔ∏è –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å —Ç–æ–≤–∞—Ä—ã", callback_data: "edit_products" },
        ],
        [
          { text: "üëÅÔ∏è –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –≤–∏–¥–∏–º–æ—Å—Ç—å—é", callback_data: "toggle_visibility" },
          { text: "üë§ –î–æ–±–∞–≤–∏—Ç—å –∞–¥–º–∏–Ω–∞", callback_data: "add_admin" },
        ],
        [
          { text: "üìã –ü—Ä–æ—Å–º–æ—Ç—Ä–µ—Ç—å —Ç–æ–≤–∞—Ä—ã", callback_data: "view_products" },
          { text: "üí∞ –ú–∞—Å—Å–æ–≤–∞—è –Ω–∞—Ü–µ–Ω–∫–∞", callback_data: "bulk_price" },
        ],
      ],
    },
  });
  logger.info("Sent admin panel", { userId });
});

// –ü–∞—Ä—Å–µ—Ä CSV
bot.action("parse_products", async (ctx) => {
  await ctx.reply("üì§ –û—Ç–ø—Ä–∞–≤—å—Ç–µ CSV-—Ñ–∞–π–ª —Å —Ç–æ–≤–∞—Ä–∞–º–∏. –ë–æ—Ç —Ä–∞—Å–ø–æ–∑–Ω–∞–µ—Ç —Å—Ç–æ–ª–±—Ü—ã (–Ω–∞–ø—Ä–∏–º–µ—Ä, name, price, description).");
  logger.info("Prompted for CSV upload", { userId: ctx.from.id });
});

bot.on("document", async (ctx) => {
  const userId = ctx.from.id.toString();
  logger.info("Received document", { userId });

  let isAdmin = false;
  try {
    isAdmin = await isAdminUser(userId);
  } catch (err) {
    logger.error("Error checking admin status in document handler", { error: err.message, userId });
    return ctx.reply("‚ùå –û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞");
  }

  if (!isAdmin) {
    logger.warn("Admin access denied for document upload", { userId });
    return;
  }

  try {
    const file = await ctx.telegram.getFile(ctx.message.document.file_id);
    const fileUrl = `https://api.telegram.org/file/bot${process.env.BOT_TOKEN}/${file.file_path}`;
    const response = await fetch(fileUrl, { timeout: 5000 });
    const buffer = await response.buffer();

    const newProducts = [];
    let columnMapping = {};

    buffer
      .pipe(csvParser())
      .on("headers", (headers) => {
        columnMapping = headers.reduce((acc, header) => {
          const field = mapColumn(header);
          if (field) acc[field] = header;
          return acc;
        }, {});
      })
      .on("data", (row) => {
        const product = {
          id: uuidv4(),
          name: columnMapping.name ? row[columnMapping.name] || "–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è" : "–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è",
          price: columnMapping.price && !isNaN(parseFloat(row[columnMapping.price]))
            ? parseFloat(row[columnMapping.price])
            : 0,
          description: columnMapping.description ? row[columnMapping.description] || "" : "",
          image_url: columnMapping.image_url ? row[columnMapping.image_url] || "" : "",
          category: columnMapping.category ? row[columnMapping.category] || "–ë–µ–∑ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏" : "–ë–µ–∑ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏",
          stock: columnMapping.stock && !isNaN(parseInt(row[columnMapping.stock]))
            ? parseInt(row[columnMapping.stock])
            : 0,
          tags: columnMapping.tags && row[columnMapping.tags]
            ? row[columnMapping.tags].split(/[;,\s]+/).filter((tag) => tag)
            : [],
          is_visible: false,
        };
        newProducts.push(product);
      })
      .on("end", async () => {
        if (newProducts.length === 0) {
          await ctx.reply("‚ö†Ô∏è CSV-—Ñ–∞–π–ª –ø—É—Å—Ç –∏–ª–∏ –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç –¥–∞–Ω–Ω—ã—Ö.");
          logger.warn("CSV file empty", { userId });
          return;
        }

        // –í—Ä–µ–º–µ–Ω–Ω–æ–µ –æ—Ç–∫–ª—é—á–µ–Ω–∏–µ Supabase
        await ctx.reply(
          `‚úÖ –§–∞–π–ª –æ–±—Ä–∞–±–æ—Ç–∞–Ω, –Ω–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Ç–æ–≤–∞—Ä–æ–≤ –≤—Ä–µ–º–µ–Ω–Ω–æ –æ—Ç–∫–ª—é—á–µ–Ω–æ –∏–∑-–∑–∞ –ø—Ä–æ–±–ª–µ–º —Å –±–∞–∑–æ–π –¥–∞–Ω–Ω—ã—Ö.`
        );
        logger.info("CSV processed, Supabase insert skipped", { userId, productCount: newProducts.length });
      });
  } catch (err) {
    logger.error("Error processing CSV", { error: err.message, userId });
    await ctx.reply("‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Ñ–∞–π–ª–∞: " + err.message);
  }
});

// –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Ç–µ–∫—Å—Ç–æ–≤—ã—Ö –∫–æ–º–∞–Ω–¥
bot.action("edit_products", async (ctx) => {
  await ctx.reply(
    "‚úèÔ∏è –í–≤–µ–¥–∏—Ç–µ: edit,id,–Ω–∞–∑–≤–∞–Ω–∏–µ,—Ü–µ–Ω–∞,–æ–ø–∏—Å–∞–Ω–∏–µ,–∫–∞—Ç–µ–≥–æ—Ä–∏—è,–æ—Å—Ç–∞—Ç–æ–∫,—Ç–µ–≥–∏ (–æ—Å—Ç–∞–≤—å—Ç–µ –ø—É—Å—Ç—ã–º –¥–ª—è —Ç–µ–∫—É—â–µ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è)"
  );
});

bot.action("toggle_visibility", async (ctx) => {
  await ctx.reply("üëÅÔ∏è –í–≤–µ–¥–∏—Ç–µ: visibility,id,true/false (–Ω–∞–ø—Ä–∏–º–µ—Ä, visibility,12345,true)");
});

bot.action("bulk_price", async (ctx) => {
  await ctx.reply("üí∞ –í–≤–µ–¥–∏—Ç–µ: bulk,percent/fixed,–∑–Ω–∞—á–µ–Ω–∏–µ (–Ω–∞–ø—Ä–∏–º–µ—Ä, bulk,percent,10)");
});

bot.action("view_products", async (ctx) => {
  await ctx.reply("‚ö†Ô∏è –ü—Ä–æ—Å–º–æ—Ç—Ä —Ç–æ–≤–∞—Ä–æ–≤ –≤—Ä–µ–º–µ–Ω–Ω–æ –æ—Ç–∫–ª—é—á—ë–Ω –∏–∑-–∑–∞ –ø—Ä–æ–±–ª–µ–º —Å –±–∞–∑–æ–π –¥–∞–Ω–Ω—ã—Ö.");
  logger.info("View products skipped due to Supabase issues", { userId: ctx.from.id });
});

bot.on("text", async (ctx) => {
  const userId = ctx.from.id.toString();
  const text = ctx.message.text;
  logger.info("Received text message", { userId, text });

  let isAdmin = false;
  try {
    isAdmin = await isAdminUser(userId);
  } catch (err) {
    logger.error("Error checking admin status in text handler", { error: err.message, userId });
    return ctx.reply("‚ùå –û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞");
  }

  if (!isAdmin) {
    logger.warn("Admin access denied for text command", { userId });
    return;
  }

  await ctx.reply("‚ö†Ô∏è –û–ø–µ—Ä–∞—Ü–∏–∏ —Å —Ç–æ–≤–∞—Ä–∞–º–∏ –≤—Ä–µ–º–µ–Ω–Ω–æ –æ—Ç–∫–ª—é—á–µ–Ω—ã –∏–∑-–∑–∞ –ø—Ä–æ–±–ª–µ–º —Å –±–∞–∑–æ–π –¥–∞–Ω–Ω—ã—Ö.");
  logger.info("Text command skipped due to Supabase issues", { userId, command: text });
});

// Webhook
app.post(`/bot${process.env.BOT_TOKEN}`, (req, res) => {
  bot.handleUpdate(req.body, res);
  logger.info("Webhook request processed");
});

// API –¥–ª—è –≤–µ–±-–ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
app.get("/api/products", async (req, res) => {
  logger.info("Received /api/products request");
  res.status(503).json({ error: "Service temporarily unavailable due to database issues" });
});

// –¢–µ—Å—Ç–æ–≤–æ–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ Supabase
app.get("/test-supabase", async (req, res) => {
  logger.info("Received /test-supabase request");
  res.status(503).json({ error: "Supabase temporarily disabled" });
});

// Keep-alive –¥–ª—è Render
const keepAlive = () => {
  setInterval(async () => {
    try {
      await fetch(`https://${process.env.RENDER_EXTERNAL_HOSTNAME}/api/products`);
      logger.info("Keep-alive ping sent");
    } catch (err) {
      logger.error("Keep-alive ping failed", { error: err.message });
    }
  }, 5 * 60 * 1000); // –ö–∞–∂–¥—ã–µ 5 –º–∏–Ω—É—Ç
};

// –ó–∞–ø—É—Å–∫ —Å–µ—Ä–≤–µ—Ä–∞
app.listen(PORT, async () => {
  logger.info(`Server started on port ${PORT}`);
  try {
    const webhookUrl = `https://${process.env.RENDER_EXTERNAL_HOSTNAME}/bot${process.env.BOT_TOKEN}`;
    await bot.telegram.setWebhook(webhookUrl);
    logger.info("Webhook set", { webhookUrl });
    keepAlive();
  } catch (err) {
    logger.error("Error setting webhook", { error: err.message });
  }
});